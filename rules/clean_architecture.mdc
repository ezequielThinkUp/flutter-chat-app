# ğŸ—ï¸ Reglas de Arquitectura Limpia - Chat App

## ğŸ“‹ Flujo de Arquitectura

```
UI
â”œâ”€â”€ Provider
â”‚   â”œâ”€â”€ State
â”‚   â””â”€â”€ Action
â”‚       â†“
â”‚   (opcional) Manager
â”‚       â†“
â”œâ”€â”€ UseCase
â”‚   â†“
â”œâ”€â”€ Repository â†’ RepositoryImpl
â”‚   â†“
â”œâ”€â”€ DataSource â†’ DataSourceImpl
â”‚   â†“
â””â”€â”€ Servicio
```

---

## ğŸ¯ **1. REGLAS DE LA CAPA UI (Presentation)**

### âœ… **Permitido:**
- Extender `BaseHookWidget` para widgets
- Extender `BaseStatefulWidget` para pantallas
- Usar `ContentStateWidget` para manejo de estados
- Acceder solo al **Provider** (nunca saltar capas)
- Importar solo de `presentation/` y `routes/`

### âŒ **Prohibido:**
- LÃ³gica de negocio en widgets
- Acceso directo a Repository/DataSource/Servicio
- Importar de `domain/` o `data/` directamente
- Estado mutable fuera del Provider

### ğŸ“ **Estructura Obligatoria:**
```
lib/presentation/flows/[feature]/
â”œâ”€â”€ state.dart              # Estado inmutable
â”œâ”€â”€ action.dart             # Acciones sealed
â”œâ”€â”€ [feature]_notifier.dart # LÃ³gica de negocio
â”œâ”€â”€ [feature]_provider.dart # Provider + extensiones
â”œâ”€â”€ [feature]_screen.dart   # Pantalla principal
â””â”€â”€ widgets/                # Widgets especÃ­ficos
```

---

## ğŸ”„ **2. REGLAS DEL PROVIDER**

### âœ… **Responsabilidades:**
- Encapsular `StateNotifier` con `BaseProvider`
- Proporcionar extensiones de conveniencia
- Manejar el estado inmutable
- Exponer acciones tipo-seguras

### âŒ **Prohibiciones:**
- LÃ³gica de negocio compleja
- Acceso directo a servicios externos
- Estado mutable
- Side effects no controlados

### ğŸ“ **Ejemplo de ImplementaciÃ³n:**
```dart
final chatProvider = BaseProvider<ChatNotifier, ChatState, ChatAction>(
  (ref) => ChatNotifier(),
);

extension ChatProviderX on WidgetRef {
  ChatState get chatState => watch(chatProvider.provider);
  void executeChatAction(ChatAction action) => /* ... */;
}
```

---

## ğŸ“¦ **3. REGLAS DEL STATE**

### âœ… **CaracterÃ­sticas Obligatorias:**
- Extender `BaseState`
- Ser completamente inmutable
- Implementar `copyWith()`
- Usar `BaseStatus` para estados de carga
- Incluir helpers para UI

### ğŸ“ **Plantilla Obligatoria:**
```dart
class FeatureState extends BaseState {
  // Propiedades inmutables
  final String data;
  final bool isLoading;
  
  const FeatureState({
    super.status = BaseStatus.initial,
    super.message,
    this.data = '',
    this.isLoading = false,
  });
  
  @override
  FeatureState copyWith({/* parÃ¡metros */}) => /* implementaciÃ³n */;
  
  // Helpers para UI
  bool get canSubmit => /* lÃ³gica */;
}
```

---

## âš¡ **4. REGLAS DE ACTIONS**

### âœ… **CaracterÃ­sticas Obligatorias:**
- Usar `sealed class` que extiende `BaseAction`
- Una acciÃ³n por operaciÃ³n especÃ­fica
- Ser inmutables y con `const` constructors
- Incluir solo datos necesarios

### ğŸ“ **Plantilla Obligatoria:**
```dart
sealed class FeatureAction extends BaseAction {
  const FeatureAction();
}

class LoadData extends FeatureAction {
  const LoadData();
  List<Object?> get props => [];
}

class UpdateField extends FeatureAction {
  final String value;
  const UpdateField(this.value);
  List<Object?> get props => [value];
}
```

---

## ğŸ§  **5. REGLAS DEL NOTIFIER (Manager)**

### âœ… **Responsabilidades:**
- Extender `BaseStateNotifier<State, Action>`
- Manejar todas las acciones con `handleAction()`
- Coordinar UseCases (cuando se implementen)
- Manejar estados de loading/error
- NO lÃ³gica de negocio pesada

### âŒ **Prohibiciones:**
- Acceso directo a servicios HTTP
- LÃ³gica de negocio compleja
- MutaciÃ³n de estado directa
- Side effects no controlados

### ğŸ“ **Estructura Obligatoria:**
```dart
class FeatureNotifier extends BaseStateNotifier<FeatureState, FeatureAction> {
  FeatureNotifier() : super(FeatureState.initial());

  @override
  Future<void> handleAction(FeatureAction action) async {
    switch (action) {
      case LoadData():
        await _handleLoadData();
      case UpdateField():
        _handleUpdateField(action);
    }
  }
  
  Future<void> _handleLoadData() async {
    state = state.copyWith(status: BaseStatus.loading);
    
    try {
      // Llamar UseCase aquÃ­ (cuando se implemente)
      final result = await useCase.execute();
      state = state.copyWith(
        status: BaseStatus.success,
        data: result,
      );
    } catch (error) {
      state = state.copyWith(
        status: BaseStatus.error,
        message: error.toString(),
      );
    }
  }
}
```

---

## ğŸ¯ **6. REGLAS DE USECASE (PrÃ³xima ImplementaciÃ³n)**

### âœ… **Cuando Implementar:**
- LÃ³gica de negocio compleja
- CoordinaciÃ³n entre mÃºltiples repositorios
- Validaciones de negocio
- Transformaciones de datos complejas

### ğŸ“ **Estructura Futura:**
```dart
abstract class UseCase<Type, Params> {
  Future<Type> execute(Params params);
}

class GetMessagesUseCase extends UseCase<List<Message>, String> {
  final MessageRepository repository;
  
  GetMessagesUseCase(this.repository);
  
  @override
  Future<List<Message>> execute(String chatId) async {
    final messages = await repository.getMessages(chatId);
    // LÃ³gica de negocio aquÃ­
    return messages.where((m) => m.isVisible).toList();
  }
}
```

---

## ğŸ—„ï¸ **7. REGLAS DE REPOSITORY (PrÃ³xima ImplementaciÃ³n)**

### âœ… **Responsabilidades:**
- Abstraer fuentes de datos
- Manejar cachÃ© local
- Coordinar mÃºltiples DataSources
- Transformar entre domain y data models

### ğŸ“ **Estructura Futura:**
```
lib/domain/repositories/
â””â”€â”€ message_repository.dart        # Abstract interface

lib/data/repositories/
â””â”€â”€ message_repository_impl.dart   # Concrete implementation
```

---

## ğŸ“¡ **8. REGLAS DE DATASOURCE (PrÃ³xima ImplementaciÃ³n)**

### âœ… **Responsabilidades:**
- Acceso directo a APIs/DB
- SerializaciÃ³n/DeserializaciÃ³n
- Manejo de errores de red
- CachÃ© de primer nivel

### ğŸ“ **Estructura Futura:**
```
lib/data/datasources/
â”œâ”€â”€ message_remote_datasource.dart  # API calls
â””â”€â”€ message_local_datasource.dart   # Local storage
```

---

## ğŸŒ **9. REGLAS DE SERVICIO (Base)**

### âœ… **Servicios Permitidos:**
- HTTP client (dio, http)
- Database (sqlite, hive)
- Socket connections
- Platform services

### âŒ **Prohibiciones:**
- LÃ³gica de negocio
- Transformaciones complejas
- Estado de aplicaciÃ³n

---

## ğŸš« **10. REGLAS DE DEPENDENCIAS**

### âœ… **Flujo de Dependencias Permitido:**
```
UI â†’ Provider â†’ State/Action â†’ Notifier â†’ UseCase â†’ Repository â†’ DataSource â†’ Service
```

### âŒ **Dependencias Prohibidas:**
- âŒ UI â†’ Repository (saltar Provider)
- âŒ Notifier â†’ Service (saltar UseCase/Repository)
- âŒ Repository â†’ UI (dependencia inversa)
- âŒ Circular dependencies

---

## ğŸ“‹ **11. CHECKLIST ANTES DE COMMIT**

### âœ… **ValidaciÃ³n Obligatoria:**
- [ ] Todas las clases usan las bases correctas
- [ ] No hay dependencias prohibidas
- [ ] Estados son inmutables
- [ ] Acciones son sealed classes
- [ ] Notifiers manejan errores
- [ ] Tests estÃ¡n actualizados
- [ ] DocumentaciÃ³n estÃ¡ completa

### ğŸ” **Comandos de ValidaciÃ³n:**
```bash
# AnÃ¡lisis de cÃ³digo
flutter analyze --no-fatal-infos

# Tests (cuando se implementen)
flutter test

# Cobertura (cuando se implemente)
flutter test --coverage
```

---

## ğŸ¯ **12. MIGRACIÃ“N GRADUAL**

### **Fase Actual: âœ… COMPLETADA**
- [x] Base classes implementadas
- [x] Flows con Provider/State/Action/Notifier
- [x] NavegaciÃ³n con go_router
- [x] Widgets compartidos

### **PrÃ³ximas Fases:**
- [ ] **Fase 2:** Implementar UseCases
- [ ] **Fase 3:** Implementar Repositories
- [ ] **Fase 4:** Implementar DataSources
- [ ] **Fase 5:** Implementar Services reales

---

## ğŸ›¡ï¸ **13. ENFORCEMENT**

### **Herramientas de ValidaciÃ³n:**
- `flutter analyze` para validaciÃ³n estÃ¡tica
- Custom lints (futuro)
- Pre-commit hooks (futuro)
- Code review checklist

### **Responsabilidades del Equipo:**
- **Senior Dev:** Review arquitectura
- **Mid Dev:** Seguir reglas establecidas  
- **Junior Dev:** Aprender y aplicar patterns

---

**ğŸ¯ Objetivo:** Mantener codebase limpio, escalable y mantenible siguiendo clean architecture principles.

**ğŸ“š Referencia:** Este documento debe ser consultado antes de crear nuevos flows o modificar existentes. 