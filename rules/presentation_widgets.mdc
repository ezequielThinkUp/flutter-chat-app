# üß© Regla ‚Äì Widgets de Presentation

**Aplica a:**
- `lib/presentation/shared/widgets/**/*.dart` - Widgets reutilizables compartidos
- `lib/presentation/widgets/**/*.dart` - Widgets espec√≠ficos de flujos

Esta regla aplica a **todos los widgets dentro de la capa `presentation`**, tanto los **reutilizables compartidos** como los **espec√≠ficos de un flujo**.

## üß© Regla ‚Äì Widgets Reutilizables

Los widgets ubicados en `lib/presentation/shared/widgets/` son componentes UI gen√©ricos, reutilizables en m√∫ltiples pantallas. Su prop√≥sito es simplificar la UI y mantenerla desacoplada de la l√≥gica de negocio.

---

## ‚úÖ Convenciones

- Extender por defecto `BaseHookWidget`, que ya implementa `HookConsumerWidget` de forma uniforme.
- El widget base `BaseHookWidget` ya est√° creado en:  
  `lib/presentation/core/base_hook_widget.dart`
- Si requiere estado local visual (ej: animaciones, focus, controladores), puede usar `HookWidget` o `StatefulHookWidget`.
- Todos los datos necesarios deben recibirse por par√°metros (`final`, `required`).
- El widget debe ser totalmente **reutilizable**: sin referencias a flows ni l√≥gica de negocio.

---

## üß± Clase base para widgets: `BaseHookWidget`

```dart
abstract class BaseHookWidget extends HookConsumerWidget {
  BaseHookWidget({
    super.key,
  });

  Widget buildView(BuildContext context, WidgetRef ref);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return buildView(context, ref);
  }
}
```

## üß© Ejemplo de widget reutilizable

```dart
class PrimaryButton extends BaseHookWidget {
  final String label;
  final VoidCallback onPressed;
  final bool enabled;

  const PrimaryButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.enabled = true,
  });

  @override
  Widget buildView(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
      onPressed: enabled ? onPressed : null,
      child: Text(label),
    );
  }
}
```

## üß† Buenas pr√°cticas de dise√±o

- Los widgets deben ser **lo m√°s peque√±os y enfocados posible**.
- Cada widget debe encargarse de **una sola parte del layout o comportamiento visual**.
- **Es preferible crear muchos widgets con poco c√≥digo** antes que dejar l√≥gica y estructura compleja dentro de la pantalla principal.
- Esta pr√°ctica mejora la legibilidad, el testing y el mantenimiento a largo plazo.
- En una `Screen`, el `buildView()` debe verse como una composici√≥n de widgets abstra√≠dos, no como un bloque gigante de UI.

## ‚ö†Ô∏è Evitar

‚ùå Acceder a `ref.read()` o `ref.watch()` para obtener l√≥gica de negocio.

‚ùå Colocar l√≥gica relacionada a use_cases, managers, o ApiServices.

‚ùå Acoplar el widget a un flujo espec√≠fico (deben poder usarse globalmente).

‚ùå Usar l√≥gica condicional compleja en el `build()` que deber√≠a resolverse en el notifier. 